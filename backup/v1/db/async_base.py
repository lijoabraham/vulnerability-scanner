from contextlib import asynccontextmanager
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from sqlalchemy.sql import text
from sqlalchemy.pool import QueuePool
from sqlalchemy.engine import url

class Database:
    def __init__(self, db_settings):
        connection_url  = url.URL(drivername='postgresql+asyncpg',
                 username=db_settings.DB_USERNAME,
                 password=db_settings.DB_PASSWORD,
                 host=db_settings.DB_HOST,
                 port=db_settings.DB_PORT,
                 database=db_settings.DB_DATABASE,
                 query={'ssl': 'require'}) 

        self.async_engine = create_async_engine(connection_url, echo=True)
        self.AsyncLocalSession = sessionmaker(self.async_engine, expire_on_commit=False, class_=AsyncSession)
        self.async_engine = create_async_engine(
            connection_url,
            echo=True,
            poolclass=QueuePool,
            pool_size=2,  # Adjust pool size as needed
            max_overflow=10,  # Adjust overflow limit as needed
        )
        self.AsyncLocalSession = sessionmaker(
            bind=self.async_engine,
            expire_on_commit=False,
            class_=AsyncSession,
        )

    @asynccontextmanager
    async def get_session(self):
        session = self.AsyncLocalSession()
        try:
            yield session
        except Exception as e:
            print(e)
            await session.rollback()
        finally:
            await session.close()

    async def close(self):
        """
        Closes the connection pool.
        """
        await self.async_engine.dispose()

    async def execute_query(self, query, *args, **kwargs):
        async with self.get_session() as session:
            await session.execute(text("SET search_path = scanner"))
            result = await session.execute(query, *args, **kwargs)
            return result

    async def fetch_all(self, query, *args, **kwargs):
        result = await self.execute_query(query, *args, **kwargs)
        return result.fetchall()

    async def fetch_one(self, query, *args, **kwargs):
        result = await self.execute_query(query, *args, **kwargs)
        return result.fetchone()

    async def insert(self, table, data):
        async with self.get_session() as session:
            async with session.begin():
                await session.execute(text("SET search_path = scanner"))
                session.add(table(**data))
                await session.commit()

    async def update(self, query, update_data, *args, **kwargs):
        async with self.get_session() as session:
            async with session.begin():
                await session.execute(query, *args, **kwargs, update_params=update_data)
                await session.commit()

    async def delete(self, query, *args, **kwargs):
        async with self.get_session() as session:
            async with session.begin():
                await session.execute(query, *args, **kwargs)
                await session.commit()
    
    async def async_session(self, func):
        async def wrapper(*args, **kwargs):
            async with self.get_session() as session:
                return await func(session, *args, **kwargs)
        return wrapper
    
